<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Infinite zoom</title>

    <style>
        #container {
            background-color: #808080;
            position: fixed;
            transform-origin: 0 0;
        }

        canvas {
            position: absolute;
            top: 0px;
            left: 0px;
            width: 100%;
            height: 100%;
            transform: translate(0, 0) scale(1);
            transition: transform 3s ease-in;
            /* transition: transform 10s cubic-bezier(0.94, 0.06, 0.47, 0.95); */
            /* http://www.css3beziercurve.net/ */
            /* https://easings.co/ */
            transform-origin: 0 0;
        }
    </style>
</head>
<body>
    <div id="container">

    </div>

    <script>
        // Canvas2D: Multiple readback operations using getImageData are faster with the willReadFrequently attribute set to true. See: https://html.spec.whatwg.org/multipage/canvas.html#concept-canvas-will-read-frequently

        // const generateImageUrl = () => `https://random.imagecdn.app/${WIDTH}/${HEIGHT}?random=${Math.random()}`;
        const generateImageUrl = () => `https://picsum.photos/${SIZE}?random=${Math.random()}`;

        const images = [];
        async function fillImages() {
            for (let i = 0; i < 10; i++) {
                const img = await loadImage(generateImageUrl());
                images.push(img);
            }
            console.log('images loaded');
        }

        const container = document.getElementById('container');
        const SIZE = 300;
        const WIDTH = SIZE;
        const HEIGHT = SIZE;
        const IMAGE_URL = generateImageUrl();
        let animationAvailable = false;

        container.style.width = WIDTH + 'px';
        container.style.height = HEIGHT + 'px';

        function round(base, dec) {
            const multiplier = Math.pow(10, dec);
            return Math.round(base * multiplier) / multiplier;
        }

        window.onresize = _ => {
            const zoomX = window.innerWidth / WIDTH;
            const zoomY = window.innerHeight / HEIGHT;

            const zoom = Math.max(zoomX, zoomY);

            const x = (window.innerWidth - WIDTH * zoom) / 2;
            const y = (window.innerHeight - HEIGHT * zoom) / 2;

            container.style.left = round(x, 2) + 'px';
            container.style.top = round(y, 2) + 'px';
            container.style.transform = `scale(${zoom})`;
            container.style.bac
        }

        window.onresize();

        container.onclick = e => {
            if (!animationAvailable) return;
            animationAvailable = false;
            const clickX = e.offsetX;
            const clickY = e.offsetY;

            // Apply zoom
            const imageZoom = SIZE * SIZE;

            // New position should keep the image point under cursor stationary
            const imagePositionX = clickX - clickX * imageZoom;
            const imagePositionY = clickY - clickY * imageZoom;

            container.style.backgroundSize = round(100 * imageZoom, 3) + '%';
            container.style.backgroundPositionX = round(imagePositionX, 3) + 'px';
            container.style.backgroundPositionY = round(imagePositionY, 3) + 'px';

            const transformZoom = round(100 * imageZoom, 3) + '%';
            const translateX = round(imagePositionX, 3) + 'px';
            const translateY = round(imagePositionY, 3) + 'px';

            const oldCanvas = container.querySelector('canvas.old');
            const pixelColor = getPixelColor(oldCanvas, clickX, clickY);

            // Create new canvas
            const newCanvas = document.createElement('canvas');
            newCanvas.width = WIDTH;
            newCanvas.height = HEIGHT;
            newCanvas.classList.add('new');
            const newCtx = newCanvas.getContext('2d');

            console.log('img load start');
            const img = images.pop();
            newCtx.drawImage(img, 0, 0, WIDTH, HEIGHT);

            // // Fill red background
            // newCtx.fillStyle = pixelColor; // 'grey';
            // newCtx.fillRect(0, 0, WIDTH, HEIGHT);

            // // Draw 1 pixel square of the selected color
            // newCtx.fillStyle = pixelColor;
            // newCtx.fillRect(100, 100, WIDTH, HEIGHT);

            // Place new canvas scaled to 1px size and positioned at clicked pixel
            newCanvas.style.transform = `translate(${clickX}px, ${clickY}px) scale(${1 / imageZoom})`;

            container.appendChild(newCanvas);

            console.log('here');

            // Trigger zoom to full size
            requestAnimationFrame(() => {
                console.log('here2');
                newCanvas.style.transform = `translate(0px, 0px) scale(1)`;
                container.querySelector('canvas.old').style.transform = `translate(${translateX}, ${translateY}) scale(${transformZoom})`;

                // // After animation, replace .old with .new
                // newCanvas.addEventListener('transitionend', () => {
                //     oldCanvas.remove();
                //     newCanvas.classList.remove('new');
                //     newCanvas.classList.add('old');
                //     console.log('transitioned');
                //     animationAvailable = true;
                // }, { once: true });
            });
            console.log('here3');

            // After animation, replace .old with .new
            newCanvas.addEventListener('transitionend', () => {
                oldCanvas.remove();
                newCanvas.classList.remove('new');
                newCanvas.classList.add('old');
                console.log('transitioned');
                animationAvailable = true;
            }, { once: true });

        };

        function getPixelColor(canvas, x, y) {
            const ctx = canvas.getContext('2d');
            const data = ctx.getImageData(x, y, 1, 1).data;
            return `rgb(${data[0]}, ${data[1]}, ${data[2]})`;
        }


        function loadImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = "Anonymous"; // To avoid CORS issues
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = url;
            });
        }

        async function processImage() {
            await fillImages();

            const img = images.pop();

            // create old canvas
            const originalCanvas = document.createElement('canvas');
            originalCanvas.classList.add('old');
            originalCanvas.width = WIDTH;
            originalCanvas.height = HEIGHT;
            const oCtx = originalCanvas.getContext('2d');
            oCtx.drawImage(img, 0, 0, WIDTH, HEIGHT);
            container.appendChild(originalCanvas);
            animationAvailable = true;
        }

        processImage();

    </script>
</body>
</html>
